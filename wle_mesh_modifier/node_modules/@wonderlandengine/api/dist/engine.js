import { CollisionComponent, AnimationComponent, LightComponent, MeshComponent, PhysXComponent, InputComponent, ViewComponent, TextComponent, Texture, Object as Object3D, Scene, Physics, I18N, } from './wonderland.js';
import { isString } from './utils/object.js';
import { Emitter } from './utils/event.js';
/**
 * Main Wonderland Engine instance.
 *
 * Controls the canvas, rendering, and JS <-> WASM communication.
 */
export class WonderlandEngine {
    /**
     * {@link Emitter} for WebXR session start events.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.onXRSessionStart.add((session, mode) => console.log(session, mode));
     * ```
     */
    onXRSessionStart = new Emitter();
    /**
     * {@link Emitter} for WebXR session end events.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.onXRSessionEnd.add(() => console.log("XR session ended."));
     * ```
     */
    onXRSessionEnd = new Emitter();
    /** Whether AR is supported by the browser. */
    arSupported = false;
    /** Whether VR is supported by the browser. */
    vrSupported = false;
    /**
     * {@link Emitter} for scene loaded events.
     *
     * Listeners get notified when a call to {@link Scene#load()} finishes,
     * which also happens after the main scene has replaced the loading screen.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.onSceneLoaded.add(() => console.log("Scene switched!"));
     * ```
     */
    onSceneLoaded = new Emitter();
    /**
     * Current main scene.
     */
    scene = null;
    /**
     * Canvas element that Wonderland Engine renders to.
     */
    canvas = null;
    /**
     * Access to the textures managed by Wonderland Engine.
     */
    textures;
    /**
     * Access to internationalization.
     */
    i18n;
    /**
     * If `true`, the component classes found in the `Dependencies` are automatically
     * registered upon component registration.
     *
     * For more information, please have a look at how to setup the {@link Component.Dependencies}
     * static attribute.
     */
    autoRegisterDependencies = true;
    /* Component class instances per type to avoid GC */
    _componentCache = {};
    /* Object class instances per type to avoid GC */
    _objectCache = [];
    /**
     * WebAssembly bridge.
     *
     * @hidden
     */
    #wasm;
    /**
     * Physics manager, only available when physx is enabled in the runtime.
     *
     * @hidden
     */
    #physics = null;
    /**
     * Create a new engine instance.
     *
     * @param wasm Wasm bridge instance
     * @param loadingScreen Loading screen .bin file data
     *
     * @hidden
     */
    constructor(wasm, loadingScreen) {
        this.#wasm = wasm;
        this.#wasm['_setEngine'](this); /* String lookup to bypass private. */
        this.#wasm._loadingScreen = loadingScreen;
        this.textures = {
            /* Backward compatibility. @todo: Remove at 1.0.0. */
            load: (filename, crossOrigin) => {
                let image = new Image();
                if (crossOrigin !== undefined) {
                    image.crossOrigin = crossOrigin;
                }
                image.src = filename;
                return new Promise((resolve, reject) => {
                    image.onload = () => {
                        let texture = new Texture(this, image);
                        if (!texture.valid) {
                            reject('Failed to add image ' +
                                image.src +
                                ' to texture atlas. Probably incompatible format.');
                        }
                        resolve(texture);
                    };
                    image.onerror = function () {
                        reject('Failed to load image. Not found or no read access');
                    };
                });
            },
        };
        this.i18n = new I18N(this);
        this._componentCache = {};
        this._objectCache.length = 0;
    }
    /**
     * Start the engine if it's not already running.
     *
     * When using the {@link loadRuntime} function, this method is called
     * automatically.
     */
    start() {
        this.wasm._wl_application_start();
    }
    /** @overload */
    registerComponent(...args) {
        if (isString(args[0])) {
            /* Registration is using `name`, `params`, and `object`. */
            this.wasm._registerComponentLegacy(args[0], args[1], args[2]);
            return;
        }
        for (const arg of args) {
            this.wasm._registerComponent(arg, this.autoRegisterDependencies);
        }
    }
    /**
     * Checks whether the given component is registered or not.
     *
     * @param typeOrClass A string representing the component typename (e.g., `'cursor-component'`),
     *     or a component class (e.g., `CursorComponent`).
     * @returns `true` if the component is registered, `false` otherwise.
     */
    isRegistered(typeOrClass) {
        return this.#wasm.isRegistered(isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName);
    }
    /**
     * Request a XR session.
     *
     * @note Please use this call instead of directly calling `navigator.xr.requestSession()`.
     * Wonderland Engine requires to be aware that a session is started, and this
     * is done through this call.
     *
     * @param mode The XR mode.
     * @param features An array of required features, e.g., `['local-floor', 'hit-test']`.
     * @param optionalFeatures An array of optional features, e.g., `['bounded-floor', 'depth-sensing']`.
     * @returns A promise resolving with the `XRSession`, a string error message otherwise.
     */
    requestXRSession(mode, features, optionalFeatures = []) {
        if (!navigator.xr) {
            const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const missingHTTPS = location.protocol !== 'https:' && !isLocalhost;
            return Promise.reject(missingHTTPS
                ? 'WebXR is only supported with HTTPS or on localhost!'
                : 'WebXR unsupported in this browser.');
        }
        return this.#wasm.webxr_request_session_func(mode, features, optionalFeatures);
    }
    /**
     * Wrap an object ID using {@link Object}.
     *
     * @note This method performs caching and will return the same
     * instance on subsequent calls.
     *
     * @param objectId ID of the object to create.
     *
     * @returns The object
     */
    wrapObject(objectId) {
        const cache = this._objectCache;
        const o = cache[objectId] || (cache[objectId] = new Object3D(this, objectId));
        return o;
    }
    /* Public Getters & Setter */
    /**
     * WebAssembly bridge.
     *
     * @note Use with care. This object is used to communicate
     * with the WebAssembly code throughout the api.
     *
     * @hidden
     */
    get wasm() {
        return this.#wasm;
    }
    /** Current WebXR session or `null` if no session active. */
    get xrSession() {
        return this.#wasm.webxr_session;
    }
    /** Current WebXR frame or `null` if no session active. */
    get xrFrame() {
        return this.#wasm.webxr_frame;
    }
    /** Current WebXR frame or `null` if no session active. */
    get xrBaseLayer() {
        return this.#wasm.webxr_baseLayer;
    }
    /** Current WebXR WebGLFramebuffr or `null` if no session active. */
    get xrFramebuffer() {
        if (!Array.isArray(this.wasm.webxr_fbo)) {
            return this.wasm.GL.framebuffers[this.wasm.webxr_fbo];
        }
        /* For now, we only use a single framebuffer. */
        return this.wasm.GL.framebuffers[this.wasm.webxr_fbo[0]];
    }
    /** Physics manager, only available when physx is enabled in the runtime. */
    get physics() {
        return this.#physics;
    }
    /* Internal-Only Methods */
    /**
     * Initialize the engine.
     *
     * @note Should be called after the WebAssembly is fully loaded.
     *
     * @hidden
     */
    _init() {
        this.scene = new Scene(this);
        /* For internal testing, we provide compatibility with DOM-less execution */
        this.canvas =
            typeof document === 'undefined'
                ? null
                : document.getElementById('canvas');
        /* Setup the error handler. This is used to to manage native errors. */
        this.#wasm._wl_set_error_callback(this.#wasm.addFunction((messagePtr) => {
            throw new Error(this.#wasm.UTF8ToString(messagePtr));
        }, 'vi'));
        this.#physics = null;
        if (this.#wasm.withPhysX) {
            /* Setup the physics callback. */
            const physics = new Physics(this);
            this.#wasm._wl_physx_set_collision_callback(this.#wasm.addFunction((a, index, type, b) => {
                const callback = physics._callbacks[a][index];
                const component = new PhysXComponent(this, this.wasm._typeIndexFor('physx'), b);
                callback(type, component);
            }, 'viiii'));
            this.#physics = physics;
        }
    }
    /**
     * Reset the runtime state, including:
     *     - Component cache
     *     - Images
     *     - Callbacks
     *
     * @note This api is meant to be used internally.
     *
     * @hidden
     */
    _reset() {
        this._componentCache = {};
        this._objectCache.length = 0;
        this.scene.reset();
        this.wasm.reset();
    }
    /**
     * Retrieves a component instance if it exists, or create and cache
     * a new one.
     *
     * @note This api is meant to be used internally. Please have a look at
     * {@link Object3D.addComponent} instead.
     *
     * @param type component type name
     * @param componentType Component manager index
     * @param componentId Component id in the manager
     *
     * @returns JavaScript instance wrapping the native component
     *
     * @hidden
     */
    _wrapComponent(type, componentType, componentId) {
        if (componentId < 0)
            return null;
        /* @todo: extremely slow in JS to do that... Better to use a Map or allocate the array. */
        const c = this._componentCache[componentType] ||
            (this._componentCache[componentType] = []);
        if (c[componentId]) {
            return c[componentId];
        }
        let component;
        if (type == 'collision') {
            component = new CollisionComponent(this, componentType, componentId);
        }
        else if (type == 'text') {
            component = new TextComponent(this, componentType, componentId);
        }
        else if (type == 'view') {
            component = new ViewComponent(this, componentType, componentId);
        }
        else if (type == 'mesh') {
            component = new MeshComponent(this, componentType, componentId);
        }
        else if (type == 'input') {
            component = new InputComponent(this, componentType, componentId);
        }
        else if (type == 'light') {
            component = new LightComponent(this, componentType, componentId);
        }
        else if (type == 'animation') {
            component = new AnimationComponent(this, componentType, componentId);
        }
        else if (type == 'physx') {
            component = new PhysXComponent(this, componentType, componentId);
        }
        else {
            const typeIndex = this.wasm._componentTypeIndices[type];
            const constructor = this.wasm._componentTypes[typeIndex];
            component = new constructor(this);
        }
        /* Sets the manager and identifier from the outside, to
         * simplify the user's constructor. */
        /* @ts-ignore */
        component._engine = this;
        component._manager = componentType;
        component._id = componentId;
        c[componentId] = component;
        return component;
    }
}
