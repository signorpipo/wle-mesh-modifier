/// <reference types="webxr" />
import { Component, ComponentProto, ComponentConstructor, Texture, Object as Object3D, Scene, Physics, I18N } from './wonderland.js';
import { ComponentProperty } from './property.js';
import { Emitter } from './utils/event.js';
import { WASM } from './wasm.js';
export type TextureCache = {
    [key: string]: Texture | ((filename: string, crossOrigin?: string) => Promise<Texture>);
    /**
     * Load an image from URL as {@link Texture}.
     *
     * @param filename URL to load from.
     * @param crossOrigin Cross origin flag for the image object.
     * @returns Loaded texture.
     */
    load: (filename: string, crossOrigin?: string) => Promise<Texture>;
};
/**
 * Main Wonderland Engine instance.
 *
 * Controls the canvas, rendering, and JS <-> WASM communication.
 */
export declare class WonderlandEngine {
    #private;
    /**
     * {@link Emitter} for WebXR session start events.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.onXRSessionStart.add((session, mode) => console.log(session, mode));
     * ```
     */
    readonly onXRSessionStart: Emitter<[XRSession, XRSessionMode]>;
    /**
     * {@link Emitter} for WebXR session end events.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.onXRSessionEnd.add(() => console.log("XR session ended."));
     * ```
     */
    readonly onXRSessionEnd: Emitter<void[]>;
    /** Whether AR is supported by the browser. */
    readonly arSupported: boolean;
    /** Whether VR is supported by the browser. */
    readonly vrSupported: boolean;
    /**
     * {@link Emitter} for scene loaded events.
     *
     * Listeners get notified when a call to {@link Scene#load()} finishes,
     * which also happens after the main scene has replaced the loading screen.
     *
     * Usage from a within a component:
     * ```js
     * this.engine.onSceneLoaded.add(() => console.log("Scene switched!"));
     * ```
     */
    readonly onSceneLoaded: Emitter<void[]>;
    /**
     * Current main scene.
     */
    readonly scene: Scene;
    /**
     * Canvas element that Wonderland Engine renders to.
     */
    canvas: HTMLCanvasElement | null;
    /**
     * Access to the textures managed by Wonderland Engine.
     */
    textures: TextureCache;
    /**
     * Access to internationalization.
     */
    i18n: I18N;
    /**
     * If `true`, the component classes found in the `Dependencies` are automatically
     * registered upon component registration.
     *
     * For more information, please have a look at how to setup the {@link Component.Dependencies}
     * static attribute.
     */
    autoRegisterDependencies: boolean;
    private _componentCache;
    private readonly _objectCache;
    /**
     * Create a new engine instance.
     *
     * @param wasm Wasm bridge instance
     * @param loadingScreen Loading screen .bin file data
     *
     * @hidden
     */
    constructor(wasm: WASM, loadingScreen: ArrayBuffer | null);
    /**
     * Start the engine if it's not already running.
     *
     * When using the {@link loadRuntime} function, this method is called
     * automatically.
     */
    start(): void;
    /**
     * Register a custom JavaScript component type.
     *
     * You can register a component directly using a class inheriting from {@link Component}:
     *
     * ```js
     * import { Component, Type } from '@wonderlandengine/api';
     *
     * export class MyComponent extends Component {
     *     static TypeName = 'my-component';
     *     static Properties = {
     *         myParam: {type: Type.Float, default: 42.0},
     *     };
     *     init() {}
     *     start() {}
     *     update(dt) {}
     *     onActivate() {}
     *     onDeactivate() {}
     *     onDestroy() {}
     * });
     *
     * // Here, we assume we have an engine already instantiated.
     * // In general, the registration occurs in the `index.js` file in your
     * // final application.
     * engine.registerComponent(MyComponent);
     * ```
     *
     * {@label CLASSES}
     * @param classes Custom component(s) extending {@link Component}.
     *
     * @since 1.0.0
     */
    registerComponent(...classes: ComponentConstructor[]): void;
    /**
     * Register a custom JavaScript component type.
     *
     * ```js
     * registerComponent('my-new-type', {
     *    myParam: {type: Type.Float, default: 42.0},
     * }, {
     *    init: function() {},
     *    start: function() {},
     *    update: function(dt) {},
     *    onActivate: function() {},
     *    onDeactivate: function() {},
     *    onDestroy: function() {},
     * });
     * ```
     *
     * @param name Name of the component.
     * @param params Dict of param names to {@link ComponentProperty}.
     * @param object Object containing functions for the component type.
     * @deprecated Use {@link WonderlandEngine.registerComponent:CLASSES} instead.
     */
    registerComponent(name: string, params: {
        [key: string]: ComponentProperty;
    }, object: ComponentProto): void;
    /**
     * Checks whether the given component is registered or not.
     *
     * @param typeOrClass A string representing the component typename (e.g., `'cursor-component'`),
     *     or a component class (e.g., `CursorComponent`).
     * @returns `true` if the component is registered, `false` otherwise.
     */
    isRegistered(typeOrClass: string | ComponentConstructor): boolean;
    /**
     * Request a XR session.
     *
     * @note Please use this call instead of directly calling `navigator.xr.requestSession()`.
     * Wonderland Engine requires to be aware that a session is started, and this
     * is done through this call.
     *
     * @param mode The XR mode.
     * @param features An array of required features, e.g., `['local-floor', 'hit-test']`.
     * @param optionalFeatures An array of optional features, e.g., `['bounded-floor', 'depth-sensing']`.
     * @returns A promise resolving with the `XRSession`, a string error message otherwise.
     */
    requestXRSession(mode: XRSessionMode, features: string[], optionalFeatures?: string[]): Promise<XRSession>;
    /**
     * Wrap an object ID using {@link Object}.
     *
     * @note This method performs caching and will return the same
     * instance on subsequent calls.
     *
     * @param objectId ID of the object to create.
     *
     * @returns The object
     */
    wrapObject(objectId: number): Object3D;
    /**
     * WebAssembly bridge.
     *
     * @note Use with care. This object is used to communicate
     * with the WebAssembly code throughout the api.
     *
     * @hidden
     */
    get wasm(): WASM;
    /** Current WebXR session or `null` if no session active. */
    get xrSession(): XRSession | null;
    /** Current WebXR frame or `null` if no session active. */
    get xrFrame(): XRFrame | null;
    /** Current WebXR frame or `null` if no session active. */
    get xrBaseLayer(): XRProjectionLayer | null;
    /** Current WebXR WebGLFramebuffr or `null` if no session active. */
    get xrFramebuffer(): WebGLFramebuffer | null;
    /** Physics manager, only available when physx is enabled in the runtime. */
    get physics(): Physics | null;
    /**
     * Initialize the engine.
     *
     * @note Should be called after the WebAssembly is fully loaded.
     *
     * @hidden
     */
    _init(): void;
    /**
     * Reset the runtime state, including:
     *     - Component cache
     *     - Images
     *     - Callbacks
     *
     * @note This api is meant to be used internally.
     *
     * @hidden
     */
    _reset(): void;
    /**
     * Retrieves a component instance if it exists, or create and cache
     * a new one.
     *
     * @note This api is meant to be used internally. Please have a look at
     * {@link Object3D.addComponent} instead.
     *
     * @param type component type name
     * @param componentType Component manager index
     * @param componentId Component id in the manager
     *
     * @returns JavaScript instance wrapping the native component
     *
     * @hidden
     */
    _wrapComponent(type: string, componentType: number, componentId: number): Component | null;
}
